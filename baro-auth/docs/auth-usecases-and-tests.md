# Auth 유즈케이스 · 누락 항목 · 테스트 시나리오 메모

## 현재 구현 흐름 정리
- **이메일 인증**: `/auth/verification/email/send-code` 로 코드 생성·저장(+발송), `/auth/verification/email/verify` 로 검증 후 verified 플래그 true.
- **회원가입**: `AuthService.signUp`에서 `ensureVerified`로 최신 인증 내역 확인/삭제 → `User`·`AuthCredential` 생성 → Access/Refresh JWT 발급(테이블 저장 없음).
- **로그인**: `AuthService.login`에서 자격 증명 확인·비밀번호 매칭 → Access/Refresh JWT 발급(테이블 저장 없음).
- **프로필**: `/auth/me` JWT 기반 인증 후 현재 사용자 정보 반환.

## 기능/설계 관점 누락 또는 개선 필요
- **리프레시 토큰 영속화 부재**: DB 테이블이 없어 발급/회수/회전 추적 불가.  
  - 필요 테이블 예시: `refresh_token(id, user_id, token, expires_at, revoked)` 또는 `series/token` 이중키(슬라이딩 세션 대응).
  - 회전 시나리오: 사용된 리프레시 토큰을 즉시 폐기, 새 토큰 저장, 이전 토큰 재사용 시 거절.
- **리프레시 재발급 API 부재**: `/auth/refresh` 같은 엔드포인트가 없음. Access 만료 후 재발급 플로우 설계 필요.
- **중복 로그인/로그아웃 정책 미정**: 여러 기기 동시 로그인 허용 여부, 로그아웃 시 리프레시 토큰 폐기 정책 필요.
- **이메일 인증 부정 케이스 처리 확장**: 잘못된 코드, 만료 코드, 이미 검증된 코드 재사용, 과도한 요청(rate limit) 등이 명세/응답코드로 정리 필요.
- **비밀번호 정책/락아웃**: 로그인 실패 횟수 제한, 비밀번호 규칙 검증이 서비스 단에 없음(현재는 단순 매칭).
- **마케팅 동의**: `User`에 저장은 되지만 철회/재동의 플로우, 감사 로그 없음.
- **오류 응답 메시지 국제화/표준화**: 현재 메시지 일부가 깨진 상태(인코딩) 및 일관되지 않음.

## 테스트 시나리오 제안 (한국어 설명 포함)
> 각 시나리오 이름은 테스트 description/DisplayName 등에 그대로 사용해 가독성을 높입니다.

- **이메일 인증**
  - `코드 전송 시 새 레코드가 저장되고 만료시각이 5분 후로 설정된다`
  - `잘못된 코드면 400, 만료된 코드면 400으로 실패한다`
  - `코드 검증 성공 후 ensureVerified 호출 시 최신 레코드가 삭제된다` (회원가입 전 준비)
- **회원가입(SignUp)**
  - `이메일 인증을 마친 사용자는 회원가입에 성공하고 User/AuthCredential이 생성된다`
  - `비인증 이메일로 회원가입 시 401(UNAUTHORIZED)을 반환한다`
  - `중복 이메일이면 409(CONFLICT)를 반환한다` (User/Credential 기준)
  - `비밀번호가 해시로 저장된다` (BCrypt matches 확인)
- **로그인(Login)**
  - `올바른 자격 증명으로 로그인 시 Access/Refresh 토큰을 발급한다`
  - `비밀번호 불일치 시 401을 반환한다`
  - `존재하지 않는 이메일이면 401을 반환한다`
- **프로필(/auth/me)**
  - `유효한 Access 토큰으로 /auth/me 호출 시 userId/email/role을 반환한다`
  - `Authorization 헤더 없거나 형식 오류면 401을 반환한다`
  - `만료/위조 토큰이면 401을 반환한다`
- **리프레시 토큰 저장/회전 (구현 필요)**
  - `로그인/회원가입 시 리프레시 토큰이 DB에 저장된다`
  - `정상 리프레시 토큰으로 /auth/refresh 호출 시 새 Access/Refresh 토큰을 발급하고 기존 토큰을 폐기 상태로 마킹한다`
  - `폐기되었거나 만료된 리프레시 토큰으로 재발급 요청 시 401을 반환한다`
  - `리프레시 토큰 재사용 시나리오(Replay)에서 401/폐기 처리` (토큰 재사용 탐지)
- **로그아웃 (구현 필요)**
  - `로그아웃 호출 시 해당 리프레시 토큰이 폐기된다`
  - `폐기된 리프레시 토큰으로 재발급/로그아웃 요청 시 401을 반환한다`
- **보안/정책**
  - `로그인 실패 5회 초과 시 일정 시간 잠금` (락아웃 정책 도입 시)
  - `마케팅 동의 true/false 저장 및 수정 가능 여부 검증` (향후 API 추가 시)

## 테스트 코드 작성 시 가이드
- **DisplayName/설명**: JUnit5 `@DisplayName` 또는 `@Nested`에 한국어 설명을 넣어 시나리오 의도를 명확히 합니다.
- **Given-When-Then 주석**: 각 테스트 내부에 `// given`, `// when`, `// then` 한국어 주석으로 맥락을 남깁니다.
- **데이터 셋업 유틸**: 이메일 인증 레코드 생성, User/Credential 생성, 토큰 발급 헬퍼 메서드를 테스트 베이스 클래스에 두어 중복을 줄입니다.
- **H2 설정**: 테스트 프로필에서 `MODE=MySQL` 사용으로 DDL 차이를 줄이고, 테이블명 예약어 충돌을 피하기 위해 명시적 테이블명(@Table) 지정.
- **토큰 만료 테스트**: JWT `exp` 시간을 짧게 주거나 Clock/JwtTokenProvider를 목킹해 만료 케이스를 손쉽게 재현합니다.

## 향후 구현/테스트 우선순위 제안
1) **리프레시 토큰 엔티티/레포/서비스/컨트롤러** 추가 및 위 회전/폐기 시나리오 테스트 구현.  
2) **이메일 인증 부정 케이스**(잘못된 코드/만료/재사용/과도 요청) 테스트 추가.  
3) **로그아웃 & 다중 기기 정책** 정의 후 테스트.  
4) **오류 응답 포맷/메시지 정비**: 인코딩/메시지 일관화 및 I18n 고려.  
5) **보안 정책**(비밀번호 규칙, 실패 잠금) 도입 시 단위/통합 테스트 추가.
